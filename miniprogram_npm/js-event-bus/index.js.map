{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["(function(caller, bus) {\n  if (typeof exports === 'object' && typeof module === 'object') {\n    module.exports = bus();\n    module.exports.default = module.exports;\n  } else if (typeof exports === 'object') {\n    exports.EventBus = bus();\n  } else {\n    caller.EventBus = bus();\n  }\n})(this, function() {\n  var EventBus = function() {\n    this.listeners = {};\n\n    this.registerListener = function(event, callback, number) {\n      var type = event.constructor.name;\n      number = this.validateNumber(number || 'any');\n\n      if (type !== 'Array') {\n        event = [event];\n      }\n\n      event.forEach(function(e) {\n        if (e.constructor.name !== 'String') {\n          throw new Error(\n            'Only `String` and array of `String` are accepted for the event names!'\n          );\n        }\n\n        that.listeners[e] = that.listeners[e] || [];\n        that.listeners[e].push({\n          callback: callback,\n          number: number,\n        });\n      });\n    };\n\n    // valiodate that the number is a vild number for the number of executions\n    this.validateNumber = function(n) {\n      var type = n.constructor.name;\n\n      if (type === 'Number') {\n        return n;\n      } else if (type === 'String' && n.toLowerCase() === 'any') {\n        return 'any';\n      }\n\n      throw new Error(\n        'Only `Number` and `any` are accepted in the number of possible executions!'\n      );\n    };\n\n    // return wether or not this event needs to be removed\n    this.toBeRemoved = function(info) {\n      var number = info.number;\n      info.execution = info.execution || 0;\n      info.execution++;\n\n      if (number === 'any' || info.execution < number) {\n        return false;\n      }\n\n      return true;\n    };\n\n    var that = this;\n    return {\n      /**\n       * Attach a callback to an event\n       * @param {string} eventName - name of the event.\n       * @param {function} callback - callback executed when this event is triggered\n       */\n      on: function(eventName, callback) {\n        that.registerListener.bind(that)(eventName, callback, 'any');\n      },\n\n      /**\n       * Attach a callback to an event. This callback will not be executed more than once if the event is trigger mutiple times\n       * @param {string} eventName - name of the event.\n       * @param {function} callback - callback executed when this event is triggered\n       */\n      once: function(eventName, callback) {\n        that.registerListener.bind(that)(eventName, callback, 1);\n      },\n\n      /**\n       * Attach a callback to an event. This callback will be executed will not be executed more than the number if the event is trigger mutiple times\n       * @param {number} number - max number of executions\n       * @param {string} eventName - name of the event.\n       * @param {function} callback - callback executed when this event is triggered\n       */\n      exactly: function(number, eventName, callback) {\n        that.registerListener.bind(that)(eventName, callback, number);\n      },\n\n      /**\n       * Kill an event with all it's callbacks\n       * @param {string} eventName - name of the event.\n       */\n      die: function(eventName) {\n        delete that.listeners[eventName];\n      },\n\n      /**\n       * Kill an event with all it's callbacks\n       * @param {string} eventName - name of the event.\n       */\n      off: function(eventName) {\n        this.die(eventName);\n      },\n\n      /**\n       * Remove the callback for the given event\n       * @param {string} eventName - name of the event.\n       * @param {callback} callback - the callback to remove (undefined to remove all of them).\n       */\n      detach: function(eventName, callback) {\n        if (callback === undefined) {\n          that.listeners[eventName] = [];\n          return true;\n        }\n\n        for (var k in that.listeners[eventName]) {\n          if (\n            that.listeners[eventName].hasOwnProperty(k) &&\n            that.listeners[eventName][k].callback === callback\n          ) {\n            that.listeners[eventName].splice(k, 1);\n            return this.detach(eventName, callback);\n          }\n        }\n\n        return true;\n      },\n\n      /**\n       * Remove all the events\n       */\n      detachAll: function() {\n        for (var eventName in that.listeners) {\n          if (that.listeners.hasOwnProperty(eventName)) {\n            this.detach(eventName);\n          }\n        }\n      },\n\n      /**\n       * Emit the event\n       * @param {string} eventName - name of the event.\n       */\n      emit: function(eventName, context) {\n        var listeners = [];\n        for (var name in that.listeners) {\n          if (that.listeners.hasOwnProperty(name)) {\n            if (name === eventName) {\n              //TODO: this lib should definitely use > ES5\n              Array.prototype.push.apply(listeners, that.listeners[name]);\n            }\n\n            if (name.indexOf('*') >= 0) {\n              var newName = name.replace(/\\*\\*/, '([^.]+.?)+');\n              newName = newName.replace(/\\*/g, '[^.]+');\n\n              var match = eventName.match(newName);\n              if (match && eventName === match[0]) {\n                Array.prototype.push.apply(listeners, that.listeners[name]);\n              }\n            }\n          }\n        }\n\n        var parentArgs = arguments;\n\n        context = context || this;\n        listeners.forEach(function(info, index) {\n          var callback = info.callback;\n          var number = info.number;\n\n          if (context) {\n            callback = callback.bind(context);\n          }\n\n          var args = [];\n          Object.keys(parentArgs).map(function(i) {\n            if (i > 1) {\n              args.push(parentArgs[i]);\n            }\n          });\n\n          // this event cannot be fired again, remove from the stack\n          if (that.toBeRemoved(info)) {\n            that.listeners[eventName].splice(index, 1);\n          }\n\n          callback.apply(null, args);\n        });\n      },\n    };\n  };\n\n  return EventBus;\n});\n"]}